import { Injectable } from '@nestjs/common'import { Connection, Model } from 'mongoose'import { InjectModel, InjectConnection } from '@nestjs/mongoose'import * as bcrypt from 'bcrypt'import { IUserService, SearchUserParams } from './users.interface'import { CreateDto } from './dto/users.dto'import { Users, UsersDocument } from './schemas/users.schema'@Injectable()export class UsersService implements IUserService {  private saltRounds = 10  constructor (    @InjectModel(Users.name) private UsersModel: Model<UsersDocument>,    @InjectConnection() private connection: Connection  ) {  }  findById (id: string) {    return this.UsersModel.findById(id).exec()  }  findByEmail (email: string) {    return this.UsersModel.findOne({ email }).exec()  }  /**   * Создание пользователя   */  create (body: CreateDto) {    const { password, ...params } = body    const passwordHash = this.getHash(password)    const user = new this.UsersModel({      passwordHash,      ...params    })    return user.save()  }  /**   * Поиск пользователей по фильтру   */  search (params: SearchUserParams) {    return this.UsersModel.find({      name: { '$regex': params?.name || '', '$options': 'i' },      email: { '$regex': params?.email || '', '$options': 'i' },      contactPhone: { '$regex': params?.contactPhone || '', '$options': 'i' },    })      .select('id email name contactPhone')      .skip(params.offset || 0)      .limit(params.limit || 10)      .exec()  }  /**   * Вернуть хеш из строки   */  getHash (pass: string): string {    return bcrypt.hashSync(pass, this.saltRounds)  }  /**   * Сверка пароля   */  compare (pass: string, hash: string): boolean {    return bcrypt.compareSync(pass, hash)  }}